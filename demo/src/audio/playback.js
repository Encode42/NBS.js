import{getElements,getSong}from"../util/globals.js";import{decodeAudioData,playNote}from"./audio.js";const instrumentMap=new Map;let stopPlaying=!0,currentTick=-1,currentLoop=0;async function prepareSong(){await Promise.all(getSong().instruments.map(t=>t.builtIn?fetch(t.audioSrc).then(e=>e.arrayBuffer()).then(e=>decodeAudioData(e)).then(e=>t.audioBuffer=e).then(()=>instrumentMap.set(t.name,t)):null)),getElements().toggle.playback.looping.disabled=!getSong().loopEnabled,getElements().toggle.playback.looping.checked=getSong().loopEnabled}function startSong(){stopPlaying=!1,getElements().button.playback.toggle.dataset.toggled="true",playSong()}function stopSong(){delete getElements().button.playback.toggle.dataset.toggled,stopPlaying=!0}function resetSong(){stopSong(),currentTick=-1,currentLoop=0}async function playSong(){if(getSong())for(var t=getSong().hasSolo,n=getSong().layers.length;!stopPlaying;){for(let e=0;e<n;e++){var o=getSong().layers[e];if((!t||o.solo)&&!o.locked){var g=o?.notes[currentTick];if(g){let e=(g.panning+o.panning)/2,t=g.pitch;getElements().toggle.playback.parity.checked&&(e=0===o.panning?g.panning:e,t-=2),playNote(g.key,instrumentMap.get(g.instrument.name),g.velocity*o.velocity/100,e,t)}}}await new Promise(e=>setTimeout(e,getSong().timePerTick)),currentTick++,currentTick===getSong().size&&(getElements().toggle.playback.looping.checked&&(0===getSong().maxLoopCount||currentLoop<getSong().maxLoopCount)?(currentLoop++,currentTick=getSong().loopStartTick):resetSong())}}export{prepareSong,startSong,stopSong,resetSong,playSong};